#ifndef COMPRESSION_PREDICTION_H
#define COMPRESSION_PREDICTION_H

#include "predictor.h"

namespace itp {
  template <typename Forward_iterator>
  Continuations_distribution::Value_type min_value_of_all_tables(Forward_iterator first, Forward_iterator last) {
    Continuations_distribution::Value_type global_minimum {-1};
    while (first != last) {
      auto local_minimum = *std::min_element(begin(*first), end(*first));
      ++first;
      if ((local_minimum < global_minimum) || (global_minimum < 0)) {
        global_minimum = local_minimum;
      }
    }

    return global_minimum;
  }

  template <typename Forward_iterator, typename T>
  void add_value_to_each(Forward_iterator first, Forward_iterator last, T value) {
    while (first != last) {
      *first += value;
      ++first;
    }
  }

  class Codes_lengths_computer {
  public:
    using Trajectories = std::vector<Continuation<Symbol_t>>;

    virtual ~Codes_lengths_computer() = default;

    virtual Continuations_distribution append_each_trajectory_and_compute(const Discrete_time_series &history,
                                                           size_t alphabet,
                                                           size_t length_of_continuation,
                                                           const Names &compressors_to_compute,
                                                           const Trajectories &possible_continuations) const;
    virtual Continuations_distribution append_each_trajectory_and_compute(const Discrete_time_series &history,
                                                           size_t alphabet,
                                                           size_t length_of_continuation,
                                                           const Names &compressors_to_compute) const;
  private:
    static constexpr size_t BITS_IN_BYTE = 8;
  };

  using Codes_lengths_computer_ptr = std::shared_ptr<Codes_lengths_computer>;

    template <typename Forward_iterator>
    inline void to_code_probabilities(Forward_iterator first, Forward_iterator last) {
    typename Forward_iterator::value_type tmp;
    while (first != last) {
      *first = pow(2, -(*first));
      ++first;
    }
  }
  
  void form_group_forecasts(Continuations_distribution &code_probabilities,
                            const std::vector<Names> &compressors_groups,
                            Weights_generator_ptr weights_generator);
  Continuations_distribution to_probabilities(Continuations_distribution code_probabilities);
  Continuations_distribution merge(const std::vector<Continuations_distribution> &tables,
                    const std::vector<size_t> &alphabets,
                    const std::vector<Double_t> &weights);
  Forecast to_pointwise_forecasts(const Continuations_distribution &, size_t, Sampler_ptr,
                                  const Desample_info &, double = 0.95);
  Symbols_distributions cumulated_for_step(const Continuations_distribution &table,
                                           std::size_t step);

  /*template <typename T>
  struct Distr_with_rec_info {
    Continuations_distribution code_probabilities;
    Sampler_ptr sampler;
    Desample_info desample_info;
    Integration_info<T> integration_info;
    };*/

    template <typename T>
  class Compression_based_predictor : public Distribution_predictor<T> {
  public:
    explicit Compression_based_predictor(size_t difference_order=0);
    explicit Compression_based_predictor(Weights_generator_ptr weights_generator,
                                         size_t difference_order = 0);

      Distr_with_rec_info<T> predict(const Time_series<T> &history, size_t horizont,
                                     const std::vector<Names> &compressors) const override final;

    void set_difference_order(size_t n);
    size_t get_difference_order() const;

  protected:
      virtual Distr_with_rec_info<T> obtain_code_probabilities(const Time_series<T> &history,
                                                               size_t horizont,
                                                               const Names &compressors) const = 0;
  private:
    Weights_generator_ptr weights_generator;
    size_t difference_order;
  };

  class Multialphabet_distribution_predictor : public Compression_based_predictor<double> {
  public:
    Multialphabet_distribution_predictor() = delete;
    Multialphabet_distribution_predictor(Codes_lengths_computer_ptr codes_lengths_computer,
                                      Sampler_ptr sampler, size_t max_q, size_t difference=0);

    Distr_with_rec_info<double>
    obtain_code_probabilities(const Time_series<double> &ts, size_t horizont,
                              const Group &compressors) const override;
  private:
    Codes_lengths_computer_ptr codes_lengths_computer;
    Sampler_ptr sampler;
    size_t log2_max_partition_cardinality;
    Weights_generator_ptr partitions_weights_gen;
  };

    template <typename T>
  class Single_alphabet_distribution_predictor : public Compression_based_predictor<T> {
  public:
    Single_alphabet_distribution_predictor() = delete;
    explicit Single_alphabet_distribution_predictor(Codes_lengths_computer_ptr codes_lengths_computer,
                                                    size_t difference=0);
  protected:
    Distr_with_rec_info<T> obtain_code_probabilities(const Time_series<T> &history,
                                                           size_t horizont,
                                                           const Names &compressors) const override final;
    virtual Sampling_result_with_alphabet sample(const Time_series<T> &history) const = 0;
  private:
    Codes_lengths_computer_ptr codes_lengths_computer;
  };

  class Real_distribution_predictor : public Single_alphabet_distribution_predictor<double> {
  public:
    Real_distribution_predictor() = delete;
    Real_distribution_predictor(Codes_lengths_computer_ptr codes_lengths_computer,
                                Sampler_ptr sampler, size_t partition_cardinality,
                                size_t difference=0);
  protected:
    Sampling_result_with_alphabet sample(const Time_series<double> &history) const override;
  private:
    Sampler_ptr sampler;
    size_t partition_cardinality;
  };

  class Discrete_distribution_predictor : public Single_alphabet_distribution_predictor<Symbol_t> {
  public:
    Discrete_distribution_predictor() = delete;
    Discrete_distribution_predictor(Codes_lengths_computer_ptr codes_lengths_computer,
                                    Sampler_ptr sampler, size_t difference=0);
  protected:
    Sampling_result_with_alphabet sample(const Time_series<Symbol_t> &history) const override;
  private:
    Sampler_ptr sampler;
  };

  template <typename T> using Distribution_predictor_ptr = std::shared_ptr<Distribution_predictor<T>>;
  using Discrete_distribution_predictor_ptr = std::shared_ptr<Discrete_distribution_predictor>;
  using Real_distribution_predictor_ptr = std::shared_ptr<Real_distribution_predictor>;

    template <typename T>
  Compression_based_predictor<T>::Compression_based_predictor(size_t difference_order)
    : Compression_based_predictor<T> {std::make_shared<Weights_generator>(), difference_order} {}

  template <typename T>
  Compression_based_predictor<T>::Compression_based_predictor(Weights_generator_ptr weights_generator,
                                                              size_t difference_order)
    : weights_generator {weights_generator}, difference_order {difference_order} {}

  template <typename T>
  void Compression_based_predictor<T>::set_difference_order(size_t n) {
    difference_order = n;
  }

  template <typename T>
  size_t Compression_based_predictor<T>::get_difference_order() const {
    return difference_order;
  }

  template <typename T>
  Distr_with_rec_info<T> Compression_based_predictor<T>::predict(const Time_series<T> &history,
                                                                       size_t horizont,
                                                                       const std::vector<Names> &compressors) const  {
    auto differentized_history = diff_n(history, difference_order);
    auto distinct_single_compressors = find_all_distinct_names(compressors);
    auto code_probabilities_result =
      obtain_code_probabilities(differentized_history.time_series, horizont,
                                distinct_single_compressors);
    form_group_forecasts(code_probabilities_result.code_probabilities, compressors, weights_generator);
    auto probabilities = to_probabilities(code_probabilities_result.code_probabilities);
    return {probabilities, code_probabilities_result.sampler,
        code_probabilities_result.desample_info,
        differentized_history.integration_info};
  }

  template <typename T>
  Single_alphabet_distribution_predictor<T>::Single_alphabet_distribution_predictor(Codes_lengths_computer_ptr codes_lengths_computer,
                                                                                    size_t difference)
    : codes_lengths_computer {codes_lengths_computer} {}

  template <typename T>
  Distr_with_rec_info<T>
  Single_alphabet_distribution_predictor<T>::obtain_code_probabilities(const Time_series<T> &history,
                                                                       size_t horizont,
                                                                       const Names &compressors) const {
    auto sampling_result_with_alphabet = sample(history);
    auto &time_series = sampling_result_with_alphabet.sampling_result.time_series;
    auto &desample_info = sampling_result_with_alphabet.sampling_result.desample_info;
    auto &alphabet = sampling_result_with_alphabet.alphabet;
    auto table = codes_lengths_computer->append_each_trajectory_and_compute(time_series,
                                                                            alphabet,
                                                                            horizont, compressors);
    to_code_probabilities(begin(table), end(table));
    return {table, sampling_result_with_alphabet.sampling_result.sampler,
        desample_info};
  }

  template <typename T>
  Basic_pointwise_predictor<T>::Basic_pointwise_predictor(Distribution_predictor_ptr<T> distribution_predictor)
    : distribution_predictor {distribution_predictor} {}

  template <typename T>
  Forecast Basic_pointwise_predictor<T>::predict(const Time_series<T> &ts, size_t horizont,
                                                 const std::vector<Names> &compressors) const {
    auto distribution = distribution_predictor->predict(ts, horizont, compressors);
    auto forecasts = to_pointwise_forecasts(distribution.code_probabilities,
                                            horizont,
                                            distribution.sampler,
                                            distribution.desample_info);
    integrate(forecasts, distribution.integration_info);
    return forecasts;
  }

  template <typename T>
  Sparse_predictor<T>::Sparse_predictor(Pointwise_predictor_ptr<T> pointwise_predictor,
                                        size_t sparse)
    : pointwise_predictor {pointwise_predictor}, sparse {sparse} {
    assert(pointwise_predictor != nullptr);
  }

} // of itp

#endif // COMPRESSION_PREDICTION_H
