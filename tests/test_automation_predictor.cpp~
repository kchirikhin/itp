#include <automation_prediction.h>

#include <gtest/gtest.h>

using namespace itp;

class GroupsFilterTest : public ::testing::Test {
protected:
  GroupsFilterTest() {
    fgroupsWithoutAutomation = filter_groups(groupsWithoutAutomation);
    fgroupsWithAutomation = filter_groups(groupsWithAutomation);
    fDoubleGroup = filter_groups(doubleGroup);
  }

  std::vector<Names> groupsWithoutAutomation = {{"zlib", "ppmd"}, {"gzip"}};
  std::vector<Names> groupsWithAutomation = {{"zlib", "ppmd", "automation"}, {"gzip"}, {"automation"}};
  std::vector<Names> doubleGroup = {{"zlib", "automation"}, {"zlib"}};

  Filtered_groups fgroupsWithoutAutomation;
  Filtered_groups fgroupsWithAutomation;
  Filtered_groups fDoubleGroup;
};

TEST_F(GroupsFilterTest, GroupsWithoutAutomation_filterGroups_IncudePureAutomationIsFalse) {
  EXPECT_FALSE(fgroupsWithoutAutomation.include_pure_automation);
}

TEST_F(GroupsFilterTest, GroupsWithoutAutomation_filterGroups_NamesWithoutAutomationAreRight) {
  EXPECT_EQ(fgroupsWithoutAutomation.names_without_automation.size(),
            groupsWithoutAutomation.size());
  EXPECT_TRUE(std::is_permutation(std::begin(fgroupsWithoutAutomation.names_without_automation),
                                  std::end(fgroupsWithoutAutomation.names_without_automation),
                                  std::begin(groupsWithoutAutomation)));
}

TEST_F(GroupsFilterTest, GroupsWithoutAutomation_filterGroups_ReplaceIsEmpty) {
  EXPECT_TRUE(fgroupsWithoutAutomation.replace.empty());
}

TEST_F(GroupsFilterTest, GroupsWithAutomation_filterGroups_IncudePureAutomationIsTrue) {
  EXPECT_TRUE(fgroupsWithAutomation.include_pure_automation);
}

TEST_F(GroupsFilterTest, GroupsWithAutomation_filterGroups_NamesWithoutAutomationAreRight) {
  EXPECT_EQ(fgroupsWithAutomation.names_without_automation.size(),
            groupsWithoutAutomation.size());
  EXPECT_TRUE(std::is_permutation(std::begin(fgroupsWithAutomation.names_without_automation),
                                  std::end(fgroupsWithAutomation.names_without_automation),
                                  std::begin(groupsWithoutAutomation)));
}

TEST_F(GroupsFilterTest, GroupsWithAutomation_filterGroups_ReplaceIsRight) {
  EXPECT_EQ(fgroupsWithAutomation.replace.size(), 1);
  EXPECT_EQ(fgroupsWithAutomation.replace["zlib_ppmd"], std::string("zlib_ppmd_automation"));
}

TEST_F(GroupsFilterTest, compressorWithAndWithoutAutomation_filterGroups_IncudePureAutomationIsFalse) {
  EXPECT_FALSE(fDoubleGroup.include_pure_automation);
}

TEST_F(GroupsFilterTest, compressorWithAndWithoutAutomation_filterGroups_NamesWithoutAutomationAreRight) {
  EXPECT_EQ(fDoubleGroup.names_without_automation.size(), 1);
  EXPECT_EQ(fDoubleGroup.names_without_automation[0], Names {"zlib"});
}

TEST_F(GroupsFilterTest, compressorWithAndWithoutAutomation_filterGroups_ReplaceIsRight) {
  EXPECT_EQ(fDoubleGroup.replace.size(), 1);
  EXPECT_EQ(fDoubleGroup.replace["zlib"], std::string("zlib_automation"));
}

TEST_F(GroupsFilterTest, compressorWithAndWithoutAutomation_filterGroups_CopyIsRight) {
  EXPECT_EQ(fDoubleGroup.copy.size(), 1);
  EXPECT_EQ(fDoubleGroup.copy[0], std::string("zlib"));
}

TEST(Sensing_DFATest, PredictOrdinarySeries) {
  Time_series<unsigned char> ts {2,0,2,3,1,1,1,3,3,1};
  Word w (begin(ts), end(ts));
  auto sdfa = std::make_shared<Sensing_DFA>(0, 3, 1);
  size_t horizont = 2;
  auto prediction = sdfa->predict(w, horizont);
  ASSERT_EQ(prediction.predicted.size(), horizont);
  EXPECT_EQ(prediction.predicted[0].symbol, 1);
  EXPECT_EQ(prediction.predicted[0].probability, 0.25);
  EXPECT_EQ(prediction.predicted[1].symbol, 1);
  EXPECT_EQ(prediction.predicted[1].probability, 0.25);
}

TEST(ComputeTrajectoryProbabilityTest, CommonCase) {
  Continuation<Symbol_t> c {1, 2, 0, 1, 2, 3};
  Automation_prediction pred {{}, {{1, 0.9}, {1, 0.91}, {0, 0.92}, {1, 0.1}, {1, 0.2}, {3, 0.5}}, 0, 3};
  EXPECT_DOUBLE_EQ(compute_trajectory_probability(c, pred), 0.9*(.09/3.)*0.92*0.1*(0.8/3)*0.5);
}

/*TEST(ComputeTrajectoryProbabilityTest, EmptyInput) {
  Continuation<Symbol_t> c {};
  EXPECT_EQ(c.size(), 0);
  Automation_prediction pred {{}, {}, 0, 3};
  EXPECT_EQ(pred.predicted.size(), 0);
  EXPECT_EQ(pred.fitted.size(), 0);
  EXPECT_DOUBLE_EQ(compute_trajectory_probability(c, pred), 1);
  }*/

/*TEST(DiscreteAutomationTest, PredictOrdinaryTimeSeries) {
  Time_series<unsigned char> ts {2,0,2,3,1,1,1,3,3,1};
  Codes_lengths_computer_ptr computer {std::make_shared<Codes_lengths_computer>()};
  Sampler_ptr sampler {std::make_shared<Sampler>()};
  auto dpredictor = std::make_shared<Discrete_distribution_predictor>(computer, sampler);
  Automation_discrete_distribution_predictor_ptr apredictor = std::make_shared<Automation_discrete_distribution_predictor>(dpredictor);
  Basic_pointwise_predictor<unsigned char> ppredictor {apredictor};
  size_t horizont = 2;
  std::vector<Names> compressors {{"zlib", "rp"}};
  Forecast result = ppredictor.predict(ts, horizont, compressors);
  EXPECT_EQ(result.index_size(), 3);
  EXPECT_EQ(result.factors_size(), horizont);
  std::vector<double> expected_forecast{1.0264274976, 1.0151519618};
  EXPECT_NEAR(result("zlib_rp", 0).point, expected_forecast[0], 1e-5);
  EXPECT_NEAR(result("zlib_rp", 1).point, expected_forecast[1], 1e-5);*/

  /*EXPECT_NE(std::find(begin(result.get_index()), end(result.get_index()), std::string("zlib")), end(result));
  EXPECT_NE(std::find(begin(result.get_index()), end(result.get_index()), std::string("rp")), end(result));
  EXPECT_NE(std::find(begin(result.get_index()), end(result.get_index()), std::string("zlib_rp")), end(result));*/

  /*compressors = {{"zlib", "rp", "automation"}};
  result = ppredictor.predict(ts, horizont, compressors);
  EXPECT_EQ(result.index_size(), 4);
  EXPECT_EQ(result.factors_size(), 2);
  expected_forecast = {1.5, 1.5};
  EXPECT_NEAR(result("automation", 0).point, expected_forecast[0], 1e-5);
  EXPECT_NEAR(result("automation", 1).point, expected_forecast[1], 1e-5);
  EXPECT_NEAR(result("zlib_rp_automation", 0).point, 1.2632137488, 1e-5);
  EXPECT_NEAR(result("zlib_rp_automation", 1).point, 1.2575759809, 1e-5);*/
//}

/*TEST(DiscreteAutomationTest, PredictKIndex) {
  Time_series<unsigned char> ts {2,1,1,1,1,1,2,2,3,1,1,2,2,2,3,4,5,3,2,3,3,1,1,0,1,1,2,3,4,5,3,4,5,3,2,2,2,2,2,3,2,3,3,4,2,3,3,1,2,2,6,6,4,2,2,3,4,4,3,2,2,2,2,3,2,2,2,2,2,1,1,2,2,3,1,2,2,3,1,1,3,2,3,2,2,1,2,3,0,1,1,2,3,2,2,2,2,2,1,1,3,3,2,2,2,1,1,2,3,1,2,1,0,1,1,1,3,2,0,0,1,3,2,1,2,1,2,1,3,3,1,2,1,0,0,2,0,0,0,1,1,1,1,2,2,0,0,1,1,1,1,2,1,0,1,1,0,0,0,0,1,2,2,1,2,4,3,3,4,3,2,3,3,1,2,2,3,3,2,2,2,2,2,1,0,1,1,1,2,2,2,2,1,2,1,1,1,1,1,3,3,3,3,4,3,3,2,2,3,3,3,2,2,2,2,3,3,2,3,2,1,1,0,1,2,1,1,2,2,2,4,3,2,3,2,1,1,2,3,3,1,2,1,1,2,2,2,4,4,3,3,2,2,3,4,5,5,5,4,4,3,4,4,3,4,4,3,2,3,3,2,3,2,2,1,2,3,3,1,1,2,3,1,2,3,3,3,2,0,1,2,3,2,1,1,0,1,1,3,3,2,3,2,1,2,3,3,2,1,2,3,3,3,1,1,0,2,2,2,2,1,2,1,0,1,2,2,3,1,3,1,2,2,1,0,0,1,1,0,1,2,1,1,1,0,0,0,1,1,1,0,0,0,2,0,0,0,0,0,1,0,2,2,1,3,2,2,1,0,0,1,1,2,1,2,3,4,3,3,4,3,3,4,5,5,4,3,3,2,2,3,3,3,3,2,2,2,2,2,2,1,2,2,2,2,1,1,2,3,3,1,1,2,1,1,2,2,2,1,2,1,1,1,2,3,3,3,3,3,3,3,4,5,5,4,4,3,2,1,3,1,1,3,2,3,3,2,0,2,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,3,2,2,2,3,4,3,5,5,5,4,2,1,2,3,4,4,5,5,4,4,3,2,3,3,2,2,2,1,2,3,2,1,2,3,3,0,2,3,1,0,0,1,2,2,2,1,1,3,4,2,2,2,2,3,4,4,3,3,3,4,3,4,3,2,3,3,4,2,2,0,3,2,0,0,1,1,0,1,1,1,2,1,1,0,1,0,0,3,3,2,2,3,2,1,2,3,2,2,2,2,1,0,1,0,0,2};
  Codes_lengths_computer_ptr computer {std::make_shared<Codes_lengths_computer>()};
  Sampler_ptr sampler {std::make_shared<Sampler>()};
  auto dpredictor = std::make_shared<Discrete_distribution_predictor>(computer, sampler);
  Automation_discrete_distribution_predictor_ptr apredictor = std::make_shared<Automation_discrete_distribution_predictor>(dpredictor);
  auto ppredictor = std::make_shared<Basic_pointwise_predictor<unsigned char>>(apredictor);
  Sparse_predictor<unsigned char> spredictor(ppredictor, 8);
  size_t horizont = 24;
  std::vector<Names> compressors {{"automation", "zlib"}};
  Forecast result = spredictor.predict(ts, horizont, compressors);
  EXPECT_EQ(result.index_size(), 2);
  EXPECT_EQ(result.factors_size(), 24);
  }*/
